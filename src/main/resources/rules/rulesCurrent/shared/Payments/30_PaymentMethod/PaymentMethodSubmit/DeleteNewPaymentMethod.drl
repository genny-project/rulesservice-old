package life.genny.rules;

import life.genny.rules.QRules;
import life.genny.qwanda.Answer;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import life.genny.utils.PaymentUtils;
import java.util.List;
import life.genny.qwanda.payments.QPaymentsAuthorizationToken.AuthorizationPaymentType;
import life.genny.qwanda.payments.QPaymentMethod;
import life.genny.qwandautils.JsonUtils;
import life.genny.payments.QPaymentsProvider;

rule "PAYMENT_METHOD_SUBMIT - Delete payment method"
	when
		rules: QRules( isState("STARTED") && isState("USER_DELETE_NEW_PAYMENT_METHOD")
							 && !isState("LOOP_NEW_PAYMENT_METHOD_ADDED") )
	then
		rules.header();
		
		rules.setState("LOOP_NEW_PAYMENT_METHOD_ADDED");

		//String deletedPaymentMethodId = $m.getData().getValue();		
		String deletedPaymentMethodId =  rules.getAsString("paymentMethodDataString");

       	String assemblyId = rules.getUser().getValue("PRI_ASSEMBLY_USER_ID", null);
       	
       	QPaymentsProvider paymentsProvider = rules.getPaymentsServiceProvider();
		String assemblyAuthToken = paymentsProvider.getPaymentsAuthKey();

       	/* Save tokens */
       	if(assemblyId != null && deletedPaymentMethodId != null) {

  			String oneTimeTransactionCardToken = null;
  			String oneTimeTransactionBankToken = null;
       		oneTimeTransactionCardToken = paymentsProvider.fetchOneTimePaymentsToken(assemblyId, assemblyAuthToken, AuthorizationPaymentType.card);
       		oneTimeTransactionBankToken = paymentsProvider.fetchOneTimePaymentsToken(assemblyId, assemblyAuthToken, AuthorizationPaymentType.bank);

			Answer cardTokenAnswer = new Answer(rules.getUser().getCode(), rules.getUser().getCode(), "PRI_ASSEMBLY_CARD_TOKEN", oneTimeTransactionCardToken);
			Answer bankTokenAnswer = new Answer(rules.getUser().getCode(), rules.getUser().getCode(), "PRI_ASSEMBLY_BANK_TOKEN", oneTimeTransactionBankToken);

			List<Answer> answers = new ArrayList<Answer>();
			answers.add(cardTokenAnswer);
			answers.add(bankTokenAnswer);

			rules.baseEntity.saveAnswers(answers);
       	}

		if(deletedPaymentMethodId != null) {

			String userCode = rules.getUser().getCode();
			String userCurrentPaymentMethods = rules.getUser().getValue("PRI_USER_PAYMENT_METHODS", null);

			Boolean isDeleted = false;
			if(userCurrentPaymentMethods != null) {

				JsonArray currentPaymentMethods = new JsonArray(userCurrentPaymentMethods);
				JsonArray newPaymentMethodsArray = new JsonArray();
				for(Object paymentMethodObj: currentPaymentMethods) {

					if(paymentMethodObj instanceof JsonObject) {

						JsonObject paymentMethod = (JsonObject)paymentMethodObj;
						QPaymentMethod paymentMethodObject = JsonUtils.fromJson(paymentMethod.toString(), QPaymentMethod.class);
						if(paymentMethod.getString("id").equals(deletedPaymentMethodId) == false) {
							newPaymentMethodsArray.add(paymentMethod);
						} else {
							if(PaymentUtils.isBankAccount(paymentMethodObject)) {

								isDeleted = paymentsProvider.deleteBankAccount(deletedPaymentMethodId, assemblyAuthToken);
							} else {
								isDeleted = paymentsProvider.deleteCard(deletedPaymentMethodId, assemblyAuthToken);
							}
						}
					}
				}

				/* Delete only if payments API returns success response for delete API */
				rules.println("is card/bank-account deleted :: "+isDeleted);
				if(isDeleted) {
					String finalPaymentMethods = newPaymentMethodsArray.toString();
					Answer paymentAnswer = new Answer(userCode, userCode, "PRI_USER_PAYMENT_METHODS", finalPaymentMethods);
	            		rules.baseEntity.saveAnswer(paymentAnswer);
				}

			}
		}

		rules.setState("DELETED_PAYMENT_METHOD");
		rules.footer();

end
