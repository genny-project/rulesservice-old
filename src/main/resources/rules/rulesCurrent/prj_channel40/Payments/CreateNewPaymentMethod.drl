package life.genny.rules;

import life.genny.rules.RulesUtils;
import life.genny.rules.QRules;

import life.genny.qwanda.Answer;

/* Sorry Adam if you read this */
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import life.genny.qwandautils.PaymentUtils;

rule "Create new payment method - user"
	agenda-group "payment-method"
	when
		rules: QRules(  isState("STARTED") && !isState("CREATED_PAYMENT_METHOD") )
		$m : QEventMessage( event_type == "PAYMENT_SUBMIT" && data.code == "USER_ADD_NEW_PAYMENT_METHOD" )

	then

		rules.header();

		String paymentMethodDataString = $m.getData().getValue();
		
		BaseEntity userBe = rules.getUser();
		String assemblyAuthKey = PaymentUtils.getAssemblyAuthKey();
		String assemblyId = userBe.getValue("PRI_ASSEMBLY_USER_ID", null);


       	/* Save tokens */
       	if(assemblyId != null) {

       		RulesUtils.println("Refreshing tokens");

  			String oneTimeTransactionCardToken = null;
  			String oneTimeTransactionBankToken = null;
       		oneTimeTransactionCardToken = PaymentUtils.fetchOneTimeAssemblyToken(rules.getQwandaServiceUrl(), rules.getUser().getCode(), rules.getToken(), assemblyId, assemblyAuthKey, "card");
       		oneTimeTransactionBankToken = PaymentUtils.fetchOneTimeAssemblyToken(rules.getQwandaServiceUrl(), rules.getUser().getCode(), rules.getToken(), assemblyId, assemblyAuthKey, "bank");
			
			Answer cardTokenAnswer = new Answer(rules.getUser().getCode(), rules.getUser().getCode(), "PRI_ASSEMBLY_CARD_TOKEN", oneTimeTransactionCardToken);
			Answer bankTokenAnswer = new Answer(rules.getUser().getCode(), rules.getUser().getCode(), "PRI_ASSEMBLY_BANK_TOKEN", oneTimeTransactionBankToken);
						
			List<Answer> answers = new ArrayList<Answer>();
			answers.add(cardTokenAnswer);
			answers.add(bankTokenAnswer);

			rules.saveAnswers(answers);		
					
			rules.println("***** ONE TIME TOKEN "+oneTimeTransactionBankToken);
			rules.println("***** ONE TIME TOKEN "+oneTimeTransactionCardToken);
       	}

		rules.println("Payment method string1 ::"+paymentMethodDataString);
		if(paymentMethodDataString != null) {
			rules.println("Payment method string2 ::"+paymentMethodDataString);
			String userCode = rules.getUser().getCode();
			RulesUtils.println(paymentMethodDataString);
			String userCurrentPaymentMethods = userBe.getValue("PRI_USER_PAYMENT_METHODS", null);
			if(userCurrentPaymentMethods != null) {

				RulesUtils.println(userCurrentPaymentMethods);

				JsonObject newPaymentMethod = new JsonObject(paymentMethodDataString);
				JsonArray currentPaymentMethods = new JsonArray(userCurrentPaymentMethods);
				currentPaymentMethods.add(newPaymentMethod);
				String finalPaymentMethods = currentPaymentMethods.toString();

				Answer paymentAnswer = new Answer(userCode, userCode, "PRI_USER_PAYMENT_METHODS", finalPaymentMethods);

	            rules.saveAnswer(paymentAnswer);
	            rules.publishData(paymentAnswer);

			}
			else {
				rules.println("Payment method string ::"+paymentMethodDataString);
				RulesUtils.println("Payment method string ::"+paymentMethodDataString);
				Answer paymentAnswer = new Answer(userCode, userCode, "PRI_USER_PAYMENT_METHODS", "[" + paymentMethodDataString + "]");

	            rules.saveAnswer(paymentAnswer);
	            rules.publishData(paymentAnswer);
			}

			 Boolean isBankAccount = PaymentUtils.isBankAccount(paymentMethodDataString);
			 
			 if(isBankAccount) {
			 	rules.println("The payment method is BANK ACCOUNT, and hence disbursing it to Assembly");
			 	PaymentUtils.disburseAccount(assemblyId, paymentMethodDataString, assemblyAuthKey);
			 }
		}


		rules.setState("CREATED_PAYMENT_METHOD");

		rules.footer();

end
